# coding=utf-8
from cgi import escape
from bs4 import BeautifulSoup
from bs4 import UnicodeDammit
import urllib2, re, os, sys
import json
import string
import cgi

def gethtml(url_str):
	try:
		url = urllib2.urlopen(url_str)
		content = url.read()
		return content
	except Exception, e:
		raise e

def has_class_and_datamodel(tag):
    return tag.has_key('class') and tag.has_key('data-model')

def gettag(content):
	soup = BeautifulSoup(content)
	li = soup.find_all(has_class_and_datamodel)
	# try:
	# 	w = open("li.txt","a")
	# 	for l in li:
	# 		w.write(str(li))
	# except Exception, e:
	# 	print e
	# li = soup.find_all("li", class_="clip")
	# print li[0]


	# 	if one.li["class"] == "clip":
	# 		print one.li["data-model"]
	return li


# url = "file:///home/arming/code/python/kippt-javascript.htm"

# url = 'https://kippt.com/jg/javascript'
# url = "https://kippt.com/joel/android-links-from-buffer"
# url = "https://kippt.com/WebOlymp/jquery-plugins"
# url = "https://kippt.com/claytonnarcis/ios-tools-3rd-party-services"
url = "https://kippt.com/jg/electronic-music"

# print gethtml(url)
html = gethtml(url)
# print gettag(html)
li = gettag(html)

try:
	fo = open("linkvalue1-1.sql","w")
except Exception, e:
	print e
sql = 'insert into link(title,url,url_domain,description,created,group_id) '\
		'values("{0}","{1}","{2}","{3}","{4}",{5});\n'	
for l in li:
	# print l["url_domain"]
	one = BeautifulSoup(str(l))
	# print one 
	title_tag = one.select("[class~=clip-title]")[0]
	# print title_tag
	url = title_tag.get("href")
	title = title_tag.get_text(strip=True)
	# print url, title

	data_tag = one.select("[class~=timeago]")[0]
	date = data_tag.get("title")

	domain_tag = BeautifulSoup(str(one.select("[class~=domain]")[0]))
	domain = domain_tag.find("span").get_text(strip=True)
	# print date, domain

	note_tag=one.select(".content")
	# print note_tag
	note = ""
	if note_tag:
		note = BeautifulSoup(str(note_tag)).select("a")[0].get_text(strip=True)

		# print note

	# print note
	

	# print sql.format(title,url,domain,note,date,1)
	fo.write(sql.format(escape(title.encode("ascii","ignore"), True),url,\
			domain,escape(note.encode("ascii","ignore"), True), date,1))

fo.close()
print "done!!!"
# css_soup = BeautifulSoup('<p class="body strikeout"></p>')
# print css_soup.p['class']
# # ["body", "strikeout"]

# css_soup = BeautifulSoup('<p class="body"></p>')
# print css_soup.p['class']

# xml_soup = BeautifulSoup('<li class="body" data="fdafda"></li><li class="body strikeout"></li>')
# li = xml_soup.find_all("li")

# for l in li:
	# one = BeautifulSoup(l,"xml")
# 	print one.li['class']
	# if one.li['data']:
	# 	print one.li['data']
# xml_soup.p['class']

# js = '''{"url_domain": "benalman.com", "app_url": "/jg/javascript/clips/3351447", "updated": "1341914076", "via": null, "likes": {"count": 0, "data": []}, "title": "Ben Alman \u00bb Immediately-Invoked Function Expression (IIFE)", "url": "http://benalman.com/news/2010/11/immediately-invoked-function-expression/", "notes": "", "saves": {"count": 0, "data": []}, "list": "/api/lists/77496/", "is_read_later": false, "comments": {"count": 0, "data": []}, "created": "1341914070", "favicon_url": "https://www.google.com/s2/u/0/favicons?domain=benalman.com", "user": {"username": "jg", "app_url": "/jg", "avatar_url": "https://secure.gravatar.com/avatar/b0734a381b23823745c79e541d530068/?default=https%3A%2F%2Fs3.amazonaws.com%2Fkippt-static%2Fimg%2Fdefault-avatar.jpg&amp;s=160", "id": 9007, "resource_uri": "/api/users/9007/"}, "article": {"updated": "1328799216", "title": "Ben Alman \u00bb Immediately-Invoked Function Expression (IIFE)", "url": "http://benalman.com/news/2010/11/immediately-invoked-function-expression/", "html": "<div><p>In case you hadn&rsquo;t noticed, I&rsquo;m a bit of a stickler for terminology. So, after hearing the popular, yet misleading, JavaScript term &ldquo;self-executing anonymous function&rdquo; (or self-invoked anonymous function) one too many times, I&rsquo;ve finally decided to organize my thoughts into an article.</p><p>In addition to providing some very thorough information about how this pattern actually works, I&rsquo;ve actually made a recommendation on what we should call it, moving forward. Also, If you want to skip ahead, you can just check out some actual <a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife\">Immediately-Invoked Function Expressions</a>, but I recommend reading the entire article.</p><p>Please understand that this article isn&rsquo;t intended to be an &ldquo;I&rsquo;m right, you&rsquo;re wrong&rdquo; kind of thing. I&rsquo;m genuinely interested in helping people understand potentially complex concepts, and feel that using consistent and accurate terminology is one of the easiest things that people can do to facilitate understanding.</p><h2>So, what&rsquo;s this all about, anyways?</h2><p>In JavaScript, every <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function\">function</a>, when invoked, creates a new execution context. Because variables and functions defined within a function may only be accessed inside, but not outside, that context, invoking a function provides a very easy way to create privacy.</p><pre>  // Because this function returns another function that has access to the\n  // \"private\" var i, the returned function is, effectively, \"privileged.\"\n\n  function makeCounter() {\n    // `i` is only accessible inside `makeCounter`.\n    var i = 0;\n\n    return function() {\n      console.log( ++i );\n    };\n  }\n\n  // Note that `counter` and `counter2` each have their own scoped `i`.\n\n  var counter = makeCounter();\n  counter(); // logs: 1\n  counter(); // logs: 2\n\n  var counter2 = makeCounter();\n  counter2(); // logs: 1\n  counter2(); // logs: 2\n\n  i; // ReferenceError: i is not defined (it only exists inside makeCounter)\n</pre><p>In many cases, you won&rsquo;t need multiple &ldquo;instances&rdquo; of whatever your <code>makeWhatever</code> function returns, and can make do with just a single instance, and in other cases, you&rsquo;re not even explicitly returning a value.</p><h3>The heart of the matter</h3><p>Now, whether you define a function like <code>function foo(){}</code> or <code>var foo = function(){}</code>, what you end up with is an identifier for a function, that you can invoke by putting parens (parentheses, <code>()</code>) after it, like <code>foo()</code>.</p><pre>  // Because a function defined like so can be invoked by putting () after\n  // the function name, like foo(), and because foo is just a reference to\n  // the function expression `function() { /* code */ }`...\n\n  var foo = function(){ /* code */ }\n\n  // ...doesn't it stand to reason that the function expression itself can\n  // be invoked, just by putting () after it?\n\n  function(){ /* code */ }(); // SyntaxError: Unexpected token (\n</pre><p>As you can see, there&rsquo;s a catch. When the parser encounters the <code>function</code> keyword in the global scope or inside a function, it treats it as a <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Statements/function\">function declaration</a> (statement), and not as a <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Operators/Special/function\">function expression</a>, by default. If you don&rsquo;t explicitly tell the parser to expect an expression, it sees what it thinks to be a <em>function declaration without a name</em> and throws a <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/SyntaxError\">SyntaxError</a> exception because function declarations require a name.</p><h3>An aside: functions, parens, and SyntaxErrors</h3><p>Interestingly enough, if you were to specify a name for that function and put parens immediately after it, the parser would also throw a SyntaxError, but for a different reason. While parens placed after an expression indicate that the expression is a function to be invoked, parens placed after a statement are totally separate from the preceding statment, and are simply a grouping operator (used as a means to control precedence of evaluation).</p><pre>  // While this function declaration is now syntactically valid, it's still\n  // a statement, and the following set of parens is invalid because the\n  // grouping operator needs to contain an expression.\n\n  function foo(){ /* code */ }(); // SyntaxError: Unexpected token )\n\n  // Now, if you put an expression in the parens, no exception is thrown...\n  // but the function isn't executed either, because this:\n\n  function foo(){ /* code */ }( 1 );\n\n  // Is really just equivalent to this, a function declaration followed by a\n  // completely unrelated expression:\n\n  function foo(){ /* code */ }\n\n  ( 1 );\n</pre><p><em>You can read more about this in Dmitry A. Soshnikov&rsquo;s highly informative article, <a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#question-about-surrounding-parentheses\">ECMA-262-3 in detail. Chapter 5. Functions</a>.</em></p><h2>Immediately-Invoked Function Expression (IIFE)</h2><p>Fortunately, the SyntaxError &ldquo;fix&rdquo; is simple. The most widely accepted way to tell the parser to expect a function expression is just to wrap in in parens, because in JavaScript, parens can&rsquo;t contain statements. At this point, when the parser encounters the <code>function</code> keyword, it knows to parse it as a function expression and not a function declaration.</p><pre>  // Either of the following two patterns can be used to immediately invoke\n  // a function expression, utilizing the function's execution context to\n  // create \"privacy.\"\n\n  (function(){ /* code */ }()); // Crockford recommends this one\n  (function(){ /* code */ })(); // But this one works just as well\n\n  // Because the point of the parens or coercing operators is to disambiguate\n  // between function expressions and function declarations, they can be\n  // omitted when the parser already expects an expression (but please see the\n  // \"important note\" below).\n\n  var i = function(){ return 10; }();\n  true &amp;&amp; function(){ /* code */ }();\n  0, function(){ /* code */ }();\n\n  // If you don't care about the return value, or the possibility of making\n  // your code slightly harder to read, you can save a byte by just prefixing\n  // the function with a unary operator.\n\n  !function(){ /* code */ }();\n  ~function(){ /* code */ }();\n  -function(){ /* code */ }();\n  +function(){ /* code */ }();\n\n  // Here's another variation, from @kuvos - I'm not sure of the performance\n  // implications, if any, of using the `new` keyword, but it works.\n  // http://twitter.com/kuvos/status/18209252090847232\n\n  new function(){ /* code */ }\n  new function(){ /* code */ }() // Only need parens if passing arguments\n</pre><h3>An important note about those parens</h3><p>In cases where the extra &ldquo;disambiguation&rdquo; parens surrounding the function expression are unnecessary (because the parser already expects an expression), it&rsquo;s still a good idea to use them when making an assignment, <em>as a matter of convention</em>.</p><p>Such parens typically indicate that the function expression will be immediately invoked, and the variable will contain the <em>result</em> of the function, not the function itself. This can save someone reading your code the trouble of having to scroll down to the bottom of what might be a very long function expression to see if it has been invoked or not.</p><p><em>As a rule of thumb, while writing unambiguous code might be technically necessary to keep the JavaScript parser from throwing SyntaxError exceptions, writing unambiguous code is also fairly necessary to keep other developers from throwing &ldquo;WTFError&rdquo; exceptions at you!</em></p><h3>Saving state with closures</h3><p>Just like when arguments may be passed when functions are invoked by their identifier, they may also be passed when immediately invoking a function expression. Because the function (aka closure) references those passed-in value(s), they become &ldquo;locked in&rdquo; such that an <strong>Immediately-Invoked Function Expression</strong> can be used to effectively save state.</p><p><em>If you want to learn more about closures, read <a href=\"http://skilldrick.co.uk/2011/04/closures-explained-with-javascript/\">Closures explained with JavaScript</a>.</em></p><pre>  // This doesn't work like you might think, because the value of `i` never\n  // gets locked in. Instead, every link, when clicked (well after the loop\n  // has finished executing), alerts the total number of elements, because\n  // that's what the value of `i` actually is at that point.\n\n  var elems = document.getElementsByTagName( 'a' );\n\n  for ( var i = 0; i < elems.length; i++ ) {\n\n    elems[ i ].addEventListener( 'click', function(e){\n      e.preventDefault();\n      alert( 'I am link #' + i );\n    }, 'false' );\n\n  }\n\n  // This works, because inside the IIFE closure, the value of `i` is locked\n  // in as `lockedInIndex`. After the loop has finished executing, even though\n  // the value of `i` is the total number of elements, inside the IIFE closure\n  // the value of `lockedInIndex` is whatever the value passed into it (`i`)\n  // was when the function expression was invoked, so when a link is clicked,\n  // the correct value is alerted.\n\n  var elems = document.getElementsByTagName( 'a' );\n\n  for ( var i = 0; i < elems.length; i++ ) {\n\n    (function( lockedInIndex ){\n\n      elems[ i ].addEventListener( 'click', function(e){\n        e.preventDefault();\n        alert( 'I am link #' + lockedInIndex );\n      }, 'false' );\n\n    })( i );\n\n  }\n\n  // You could also use an IIFE like this as a closure that encompasses (and\n  // returns) only the click handler function, and not the entire\n  // `addEventListener` assignment. Either way, while both examples lock in\n  // the value using an IIFE, I find the previous example to be more readable.\n\n  var elems = document.getElementsByTagName( 'a' );\n\n  for ( var i = 0; i < elems.length; i++ ) {\n\n    elems[ i ].addEventListener( 'click', (function( lockedInIndex ){\n      return function(e){\n        e.preventDefault();\n        alert( 'I am link #' + lockedInIndex );\n      };\n    })( i ), 'false' );\n\n  }\n</pre><p><em>Note that in the last two examples, <code>lockedInIndex</code> could have just been called <code>i</code> without any issue, but using a differently named identifier as a function argument makes the concept significantly easier to explain.</em></p><p>One of the most advantageous side effects of Immediately-Invoked Function Expressions is that, because this unnamed, or anonymous, function expression is invoked immediately, without using an identifier, a closure can be used without polluting the current scope.</p><h3>What&rsquo;s wrong with &ldquo;Self-executing anonymous function?&rdquo;</h3><p>You&rsquo;ve already seen it mentioned a few times, but in case it wasn&rsquo;t clear, I&rsquo;m proposing the term &ldquo;<strong>Immediately-Invoked Function Expression</strong>&rdquo;, and &ldquo;<strong>IIFE</strong>&rdquo; if you like acronyms. The pronunciation <a href=\"http://www.forvo.com/word/iffy/\">&ldquo;iffy&rdquo;</a> was suggested to me, and I like it, so let&rsquo;s go with that.</p><p>What is an <strong>Immediately-Invoked Function Expression</strong>? It&rsquo;s a <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Operators/Special/function\">function expression</a> that gets invoked immediately. Just like the name would lead you to believe.</p><p>I&rsquo;d like to see JavaScript community members adopt the term <strong>&ldquo;Immediately-Invoked Function Expression&rdquo;</strong> and <strong>&ldquo;IIFE&rdquo;</strong> in their articles and presentations, because I feel it makes understanding this concept a little easier, and because the term &ldquo;self-executing anonymous function&rdquo; isn&rsquo;t really even accurate:</p><pre>  // This is a self-executing function. It's a function that executes (or\n  // invokes) itself, recursively:\n\n  function foo() { foo(); }\n\n  // This is a self-executing anonymous function. Because it has no\n  // identifier, it must use the  the `arguments.callee` property (which\n  // specifies the currently executing function) to execute itself.\n\n  var foo = function() { arguments.callee(); };\n\n  // This *might* be a self-executing anonymous function, but only while the\n  // `foo` identifier actually references it. If you were to change `foo` to\n  // something else, you'd have a \"used-to-self-execute\" anonymous function.\n\n  var foo = function() { foo(); };\n\n  // Some people call this a \"self-executing anonymous function\" even though\n  // it's not self-executing, because it doesn't invoke itself. It is\n  // immediately invoked, however.\n\n  (function(){ /* code */ }());\n\n  // Adding an identifier to a function expression (thus creating a named\n  // function expression) can be extremely helpful when debugging. Once named,\n  // however, the function is no longer anonymous.\n\n  (function foo(){ /* code */ }());\n\n  // IIFEs can also be self-executing, although this is, perhaps, not the most\n  // useful pattern.\n\n  (function(){ arguments.callee(); }());\n  (function foo(){ foo(); }());\n\n  // One last thing to note: this will cause an error in BlackBerry 5, because\n  // inside a named function expression, that name is undefined. Awesome, huh?\n\n  (function foo(){ foo(); }());\n</pre><p>Hopefully these examples have made it clear that the term &ldquo;self-executing&rdquo; is somewhat misleading, because it&rsquo;s not the function that&rsquo;s executing <em>itself</em>, even though the function is being executed. Also, &ldquo;anonymous&rdquo; is unnecessarily specific, since an <strong>Immediately Invoked Function Expression</strong> can be either anonymous or named. And as for my preferring &ldquo;invoked&rdquo; over &ldquo;executed,&rdquo; it&rsquo;s a simple matter of <a href=\"http://en.wikipedia.org/wiki/Alliteration\">alliteration</a>; I think &ldquo;<strong>IIFE</strong>&rdquo; looks and sounds nicer than &ldquo;IEFE.&rdquo;</p><p>So, that&rsquo;s it. That&rsquo;s my big idea.</p><p><em>Fun fact: because <code>arguments.callee</code> is <a href=\"https://developer.mozilla.org/en/JavaScript/Strict_mode#Differences_in_functions\">deprecated in ECMAScript 5 strict mode</a> it&rsquo;s actually technically impossible to create a &ldquo;self-executing anonymous function&rdquo; in ECMAScript 5 strict mode.</em></p><h3>A final aside: The Module Pattern</h3><p>While I&rsquo;m invoking function expressions, I&rsquo;d be remiss if I didn&rsquo;t at least <em>mention</em> the Module Pattern. If you&rsquo;re not familiar with the Module Pattern in JavaScript, it&rsquo;s similar to my first example, but with an Object being returned instead of a Function (and is generally implemented as a singleton, as in this example).</p><pre>  // Create an anonymous function expression that gets invoked immediately,\n  // and assign its *return value* to a variable. This approach \"cuts out the\n  // middleman\" of the named `makeWhatever` function reference.\n  // \n  // As explained in the above \"important note,\" even though parens are not\n  // required around this function expression, they should still be used as a\n  // matter of convention to help clarify that the variable is being set to\n  // the function's *result* and not the function itself.\n\n  var counter = (function(){\n    var i = 0;\n\n    return {\n      get: function(){\n        return i;\n      },\n      set: function( val ){\n        i = val;\n      },\n      increment: function() {\n        return ++i;\n      }\n    };\n  }());\n\n  // `counter` is an object with properties, which in this case happen to be\n  // methods.\n\n  counter.get(); // 0\n  counter.set( 3 );\n  counter.increment(); // 4\n  counter.increment(); // 5\n\n  counter.i; // undefined (`i` is not a property of the returned object)\n  i; // ReferenceError: i is not defined (it only exists inside the closure)\n</pre><p>The Module Pattern approach is not only incredibly powerful, but incredibly simple. With very little code, you can effectively namespace related methods and properties, organizing entire <em>modules</em> of code in a way that both minimizes global scope pollution and creates privacy.</p><h2>Further reading</h2><p>Hopefully this article was informative and has answered some of your questions. Of course, if you now have even more questions than when you started, you can learn even more about functions and the module pattern by reading the following articles.</p><p><em>I&rsquo;d like to thank <a href=\"http://asenbozhilov.com/\">Asen Bozhilov</a> and <a href=\"http://allyoucanleet.com/\">John David Dalton</a> for contributing technical advice, as well as <a href=\"http://skilldrick.co.uk/\">Nick Morgan</a> for his insights. If you&rsquo;d also like to contribute, please post any suggestions or feedback in the comments, thanks!</em></p></div>", "id": 49922, "resource_uri": "/api/articles/49922/"}, "is_starred": false, "id": 3351447, "resource_uri": "/api/clips/3351447/"}'''
# js1 = {"url_domain": "benalman.com", "app_url": "/jg/javascript/clips/3351447", "updated": "1341914076", "via": null, "likes": {"count": 0, "data": []}, "title": "Ben Alman \u00bb Immediately-Invoked Function Expression (IIFE)", "url": "http://benalman.com/news/2010/11/immediately-invoked-function-expression/", "notes": "", "saves": {"count": 0, "data": []}, "list": "/api/lists/77496/", "is_read_later": false, "comments": {"count": 0, "data": []}, "created": "1341914070", "favicon_url": "https://www.google.com/s2/u/0/favicons?domain=benalman.com", "user": {"username": "jg", "app_url": "/jg", "avatar_url": "https://secure.gravatar.com/avatar/b0734a381b23823745c79e541d530068/?default=https%3A%2F%2Fs3.amazonaws.com%2Fkippt-static%2Fimg%2Fdefault-avatar.jpg&amp;s=160", "id": 9007, "resource_uri": "/api/users/9007/"}, "article": {"updated": "1328799216", "title": "Ben Alman \u00bb Immediately-Invoked Function Expression (IIFE)", "url": "http://benalman.com/news/2010/11/immediately-invoked-function-expression/", "html": "<div><p>In case you hadn&rsquo;t noticed, I&rsquo;m a bit of a stickler for terminology. So, after hearing the popular, yet misleading, JavaScript term &ldquo;self-executing anonymous function&rdquo; (or self-invoked anonymous function) one too many times, I&rsquo;ve finally decided to organize my thoughts into an article.</p><p>In addition to providing some very thorough information about how this pattern actually works, I&rsquo;ve actually made a recommendation on what we should call it, moving forward. Also, If you want to skip ahead, you can just check out some actual <a href=\"http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife\">Immediately-Invoked Function Expressions</a>, but I recommend reading the entire article.</p><p>Please understand that this article isn&rsquo;t intended to be an &ldquo;I&rsquo;m right, you&rsquo;re wrong&rdquo; kind of thing. I&rsquo;m genuinely interested in helping people understand potentially complex concepts, and feel that using consistent and accurate terminology is one of the easiest things that people can do to facilitate understanding.</p><h2>So, what&rsquo;s this all about, anyways?</h2><p>In JavaScript, every <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function\">function</a>, when invoked, creates a new execution context. Because variables and functions defined within a function may only be accessed inside, but not outside, that context, invoking a function provides a very easy way to create privacy.</p><pre>  // Because this function returns another function that has access to the\n  // \"private\" var i, the returned function is, effectively, \"privileged.\"\n\n  function makeCounter() {\n    // `i` is only accessible inside `makeCounter`.\n    var i = 0;\n\n    return function() {\n      console.log( ++i );\n    };\n  }\n\n  // Note that `counter` and `counter2` each have their own scoped `i`.\n\n  var counter = makeCounter();\n  counter(); // logs: 1\n  counter(); // logs: 2\n\n  var counter2 = makeCounter();\n  counter2(); // logs: 1\n  counter2(); // logs: 2\n\n  i; // ReferenceError: i is not defined (it only exists inside makeCounter)\n</pre><p>In many cases, you won&rsquo;t need multiple &ldquo;instances&rdquo; of whatever your <code>makeWhatever</code> function returns, and can make do with just a single instance, and in other cases, you&rsquo;re not even explicitly returning a value.</p><h3>The heart of the matter</h3><p>Now, whether you define a function like <code>function foo(){}</code> or <code>var foo = function(){}</code>, what you end up with is an identifier for a function, that you can invoke by putting parens (parentheses, <code>()</code>) after it, like <code>foo()</code>.</p><pre>  // Because a function defined like so can be invoked by putting () after\n  // the function name, like foo(), and because foo is just a reference to\n  // the function expression `function() { /* code */ }`...\n\n  var foo = function(){ /* code */ }\n\n  // ...doesn't it stand to reason that the function expression itself can\n  // be invoked, just by putting () after it?\n\n  function(){ /* code */ }(); // SyntaxError: Unexpected token (\n</pre><p>As you can see, there&rsquo;s a catch. When the parser encounters the <code>function</code> keyword in the global scope or inside a function, it treats it as a <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Statements/function\">function declaration</a> (statement), and not as a <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Operators/Special/function\">function expression</a>, by default. If you don&rsquo;t explicitly tell the parser to expect an expression, it sees what it thinks to be a <em>function declaration without a name</em> and throws a <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/SyntaxError\">SyntaxError</a> exception because function declarations require a name.</p><h3>An aside: functions, parens, and SyntaxErrors</h3><p>Interestingly enough, if you were to specify a name for that function and put parens immediately after it, the parser would also throw a SyntaxError, but for a different reason. While parens placed after an expression indicate that the expression is a function to be invoked, parens placed after a statement are totally separate from the preceding statment, and are simply a grouping operator (used as a means to control precedence of evaluation).</p><pre>  // While this function declaration is now syntactically valid, it's still\n  // a statement, and the following set of parens is invalid because the\n  // grouping operator needs to contain an expression.\n\n  function foo(){ /* code */ }(); // SyntaxError: Unexpected token )\n\n  // Now, if you put an expression in the parens, no exception is thrown...\n  // but the function isn't executed either, because this:\n\n  function foo(){ /* code */ }( 1 );\n\n  // Is really just equivalent to this, a function declaration followed by a\n  // completely unrelated expression:\n\n  function foo(){ /* code */ }\n\n  ( 1 );\n</pre><p><em>You can read more about this in Dmitry A. Soshnikov&rsquo;s highly informative article, <a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#question-about-surrounding-parentheses\">ECMA-262-3 in detail. Chapter 5. Functions</a>.</em></p><h2>Immediately-Invoked Function Expression (IIFE)</h2><p>Fortunately, the SyntaxError &ldquo;fix&rdquo; is simple. The most widely accepted way to tell the parser to expect a function expression is just to wrap in in parens, because in JavaScript, parens can&rsquo;t contain statements. At this point, when the parser encounters the <code>function</code> keyword, it knows to parse it as a function expression and not a function declaration.</p><pre>  // Either of the following two patterns can be used to immediately invoke\n  // a function expression, utilizing the function's execution context to\n  // create \"privacy.\"\n\n  (function(){ /* code */ }()); // Crockford recommends this one\n  (function(){ /* code */ })(); // But this one works just as well\n\n  // Because the point of the parens or coercing operators is to disambiguate\n  // between function expressions and function declarations, they can be\n  // omitted when the parser already expects an expression (but please see the\n  // \"important note\" below).\n\n  var i = function(){ return 10; }();\n  true &amp;&amp; function(){ /* code */ }();\n  0, function(){ /* code */ }();\n\n  // If you don't care about the return value, or the possibility of making\n  // your code slightly harder to read, you can save a byte by just prefixing\n  // the function with a unary operator.\n\n  !function(){ /* code */ }();\n  ~function(){ /* code */ }();\n  -function(){ /* code */ }();\n  +function(){ /* code */ }();\n\n  // Here's another variation, from @kuvos - I'm not sure of the performance\n  // implications, if any, of using the `new` keyword, but it works.\n  // http://twitter.com/kuvos/status/18209252090847232\n\n  new function(){ /* code */ }\n  new function(){ /* code */ }() // Only need parens if passing arguments\n</pre><h3>An important note about those parens</h3><p>In cases where the extra &ldquo;disambiguation&rdquo; parens surrounding the function expression are unnecessary (because the parser already expects an expression), it&rsquo;s still a good idea to use them when making an assignment, <em>as a matter of convention</em>.</p><p>Such parens typically indicate that the function expression will be immediately invoked, and the variable will contain the <em>result</em> of the function, not the function itself. This can save someone reading your code the trouble of having to scroll down to the bottom of what might be a very long function expression to see if it has been invoked or not.</p><p><em>As a rule of thumb, while writing unambiguous code might be technically necessary to keep the JavaScript parser from throwing SyntaxError exceptions, writing unambiguous code is also fairly necessary to keep other developers from throwing &ldquo;WTFError&rdquo; exceptions at you!</em></p><h3>Saving state with closures</h3><p>Just like when arguments may be passed when functions are invoked by their identifier, they may also be passed when immediately invoking a function expression. Because the function (aka closure) references those passed-in value(s), they become &ldquo;locked in&rdquo; such that an <strong>Immediately-Invoked Function Expression</strong> can be used to effectively save state.</p><p><em>If you want to learn more about closures, read <a href=\"http://skilldrick.co.uk/2011/04/closures-explained-with-javascript/\">Closures explained with JavaScript</a>.</em></p><pre>  // This doesn't work like you might think, because the value of `i` never\n  // gets locked in. Instead, every link, when clicked (well after the loop\n  // has finished executing), alerts the total number of elements, because\n  // that's what the value of `i` actually is at that point.\n\n  var elems = document.getElementsByTagName( 'a' );\n\n  for ( var i = 0; i < elems.length; i++ ) {\n\n    elems[ i ].addEventListener( 'click', function(e){\n      e.preventDefault();\n      alert( 'I am link #' + i );\n    }, 'false' );\n\n  }\n\n  // This works, because inside the IIFE closure, the value of `i` is locked\n  // in as `lockedInIndex`. After the loop has finished executing, even though\n  // the value of `i` is the total number of elements, inside the IIFE closure\n  // the value of `lockedInIndex` is whatever the value passed into it (`i`)\n  // was when the function expression was invoked, so when a link is clicked,\n  // the correct value is alerted.\n\n  var elems = document.getElementsByTagName( 'a' );\n\n  for ( var i = 0; i < elems.length; i++ ) {\n\n    (function( lockedInIndex ){\n\n      elems[ i ].addEventListener( 'click', function(e){\n        e.preventDefault();\n        alert( 'I am link #' + lockedInIndex );\n      }, 'false' );\n\n    })( i );\n\n  }\n\n  // You could also use an IIFE like this as a closure that encompasses (and\n  // returns) only the click handler function, and not the entire\n  // `addEventListener` assignment. Either way, while both examples lock in\n  // the value using an IIFE, I find the previous example to be more readable.\n\n  var elems = document.getElementsByTagName( 'a' );\n\n  for ( var i = 0; i < elems.length; i++ ) {\n\n    elems[ i ].addEventListener( 'click', (function( lockedInIndex ){\n      return function(e){\n        e.preventDefault();\n        alert( 'I am link #' + lockedInIndex );\n      };\n    })( i ), 'false' );\n\n  }\n</pre><p><em>Note that in the last two examples, <code>lockedInIndex</code> could have just been called <code>i</code> without any issue, but using a differently named identifier as a function argument makes the concept significantly easier to explain.</em></p><p>One of the most advantageous side effects of Immediately-Invoked Function Expressions is that, because this unnamed, or anonymous, function expression is invoked immediately, without using an identifier, a closure can be used without polluting the current scope.</p><h3>What&rsquo;s wrong with &ldquo;Self-executing anonymous function?&rdquo;</h3><p>You&rsquo;ve already seen it mentioned a few times, but in case it wasn&rsquo;t clear, I&rsquo;m proposing the term &ldquo;<strong>Immediately-Invoked Function Expression</strong>&rdquo;, and &ldquo;<strong>IIFE</strong>&rdquo; if you like acronyms. The pronunciation <a href=\"http://www.forvo.com/word/iffy/\">&ldquo;iffy&rdquo;</a> was suggested to me, and I like it, so let&rsquo;s go with that.</p><p>What is an <strong>Immediately-Invoked Function Expression</strong>? It&rsquo;s a <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Operators/Special/function\">function expression</a> that gets invoked immediately. Just like the name would lead you to believe.</p><p>I&rsquo;d like to see JavaScript community members adopt the term <strong>&ldquo;Immediately-Invoked Function Expression&rdquo;</strong> and <strong>&ldquo;IIFE&rdquo;</strong> in their articles and presentations, because I feel it makes understanding this concept a little easier, and because the term &ldquo;self-executing anonymous function&rdquo; isn&rsquo;t really even accurate:</p><pre>  // This is a self-executing function. It's a function that executes (or\n  // invokes) itself, recursively:\n\n  function foo() { foo(); }\n\n  // This is a self-executing anonymous function. Because it has no\n  // identifier, it must use the  the `arguments.callee` property (which\n  // specifies the currently executing function) to execute itself.\n\n  var foo = function() { arguments.callee(); };\n\n  // This *might* be a self-executing anonymous function, but only while the\n  // `foo` identifier actually references it. If you were to change `foo` to\n  // something else, you'd have a \"used-to-self-execute\" anonymous function.\n\n  var foo = function() { foo(); };\n\n  // Some people call this a \"self-executing anonymous function\" even though\n  // it's not self-executing, because it doesn't invoke itself. It is\n  // immediately invoked, however.\n\n  (function(){ /* code */ }());\n\n  // Adding an identifier to a function expression (thus creating a named\n  // function expression) can be extremely helpful when debugging. Once named,\n  // however, the function is no longer anonymous.\n\n  (function foo(){ /* code */ }());\n\n  // IIFEs can also be self-executing, although this is, perhaps, not the most\n  // useful pattern.\n\n  (function(){ arguments.callee(); }());\n  (function foo(){ foo(); }());\n\n  // One last thing to note: this will cause an error in BlackBerry 5, because\n  // inside a named function expression, that name is undefined. Awesome, huh?\n\n  (function foo(){ foo(); }());\n</pre><p>Hopefully these examples have made it clear that the term &ldquo;self-executing&rdquo; is somewhat misleading, because it&rsquo;s not the function that&rsquo;s executing <em>itself</em>, even though the function is being executed. Also, &ldquo;anonymous&rdquo; is unnecessarily specific, since an <strong>Immediately Invoked Function Expression</strong> can be either anonymous or named. And as for my preferring &ldquo;invoked&rdquo; over &ldquo;executed,&rdquo; it&rsquo;s a simple matter of <a href=\"http://en.wikipedia.org/wiki/Alliteration\">alliteration</a>; I think &ldquo;<strong>IIFE</strong>&rdquo; looks and sounds nicer than &ldquo;IEFE.&rdquo;</p><p>So, that&rsquo;s it. That&rsquo;s my big idea.</p><p><em>Fun fact: because <code>arguments.callee</code> is <a href=\"https://developer.mozilla.org/en/JavaScript/Strict_mode#Differences_in_functions\">deprecated in ECMAScript 5 strict mode</a> it&rsquo;s actually technically impossible to create a &ldquo;self-executing anonymous function&rdquo; in ECMAScript 5 strict mode.</em></p><h3>A final aside: The Module Pattern</h3><p>While I&rsquo;m invoking function expressions, I&rsquo;d be remiss if I didn&rsquo;t at least <em>mention</em> the Module Pattern. If you&rsquo;re not familiar with the Module Pattern in JavaScript, it&rsquo;s similar to my first example, but with an Object being returned instead of a Function (and is generally implemented as a singleton, as in this example).</p><pre>  // Create an anonymous function expression that gets invoked immediately,\n  // and assign its *return value* to a variable. This approach \"cuts out the\n  // middleman\" of the named `makeWhatever` function reference.\n  // \n  // As explained in the above \"important note,\" even though parens are not\n  // required around this function expression, they should still be used as a\n  // matter of convention to help clarify that the variable is being set to\n  // the function's *result* and not the function itself.\n\n  var counter = (function(){\n    var i = 0;\n\n    return {\n      get: function(){\n        return i;\n      },\n      set: function( val ){\n        i = val;\n      },\n      increment: function() {\n        return ++i;\n      }\n    };\n  }());\n\n  // `counter` is an object with properties, which in this case happen to be\n  // methods.\n\n  counter.get(); // 0\n  counter.set( 3 );\n  counter.increment(); // 4\n  counter.increment(); // 5\n\n  counter.i; // undefined (`i` is not a property of the returned object)\n  i; // ReferenceError: i is not defined (it only exists inside the closure)\n</pre><p>The Module Pattern approach is not only incredibly powerful, but incredibly simple. With very little code, you can effectively namespace related methods and properties, organizing entire <em>modules</em> of code in a way that both minimizes global scope pollution and creates privacy.</p><h2>Further reading</h2><p>Hopefully this article was informative and has answered some of your questions. Of course, if you now have even more questions than when you started, you can learn even more about functions and the module pattern by reading the following articles.</p><p><em>I&rsquo;d like to thank <a href=\"http://asenbozhilov.com/\">Asen Bozhilov</a> and <a href=\"http://allyoucanleet.com/\">John David Dalton</a> for contributing technical advice, as well as <a href=\"http://skilldrick.co.uk/\">Nick Morgan</a> for his insights. If you&rsquo;d also like to contribute, please post any suggestions or feedback in the comments, thanks!</em></p></div>", "id": 49922, "resource_uri": "/api/articles/49922/"}, "is_starred": false, "id": 3351447, "resource_uri": "/api/clips/3351447/"}
# print js1["url_domain"]
# a = string.replace(js,"false",False)
# print json.decoder.decode(JSONDecoder(js))
# print json.dumps(js,indent=4, separators=(',', ': '))
# print json.loads(js)


# u = urllib2.urlopen('http://www.reddit.com/.json')
# print json.load(u)
# u.close()